\chapter{Virtual Memory}

\section{Introduction to vmem in Zeke}

Each process has its own master page table and varying number of L2 page
tables. Kernel (also abstracted as proc 0) has its own master page table
too. Static/fixed entries are copied to all master page tables created.
Process shares its master page table with its childs.

\textbf{ARM note:} Only 4 kB pages are used with L2 page tables so
XN (Execute-Never) bit is always usable also for L2 pages.

\subsection{Domains}

See \verb+MMU_DOM_xxx+ definitions.

\subsection{Virtual memory abstraction levels}

\begin{figure}
\begin{verbatim}
U                      +---------------+
S                      |    malloc     |
R                      +---------------+
------------------------------ | -----------
K   +---------------+  +---------------+
E   |    kmalloc    |  |     proc      |
R   +---------------+  +---------------+
N           |     /\    |      |
E           |     |    \/      |
L           |  +--------+   +----+
            |  |vralloc |---| vm |
            |  +--------+   +----+
            |     |            |
           \/    \/           \/
    +---------------+     +----------+
    |    dynmem     |-----| ptmapper |
    +---------------+     +----------+
            |                  |
           \/                  |
    +---------------+          |
    |    mmu HAL    |<----------
    +---------------+
            |
    +-----------------------+
    | CPU specific MMU code |
    +-----------------------+
----------- | ------------------------------
H   +-------------------+
W   | MMU & coProcessor |
    +-------------------+
\end{verbatim}
\caption{Virtual memory related subsystems in Zeke.}
\label{figure:vmsubsys}
\end{figure}

Virtual memory is managed as virtual memory regions (\verb+vm_region_t+) that
are abstractions of \verb+mmu_region_t+ embedded with memory allocator
information. Goal of this arrangement is to allow copy-on-write as well as
support schemes where part of the memory is stored on secondary storage
(i.e. paging).

Due to the fact that \verb+vm_region_t+ structures are used by multiple
allocators there is no global knowledge of the actual state of a particular
allocation, instead each allocator should/may keep track of allocation structs
if desired so. Ideally the same struct can be reused when moving data from a
secondary storage allocator to vralloc memory (physical memory).


See figure \ref{figure:vmsubsys}.

\begin{itemize}
  \item \verb+kmalloc+  - is a kernel level memory allocation service, used
                        solely for memory allocations in kernel space.
  \item \verb+vralloc+  - VRAlloc is a special memory allocator targeted to
                        allocate blocks of memory that will be mapped in virtual
                        address space of a processes, it returns
                        \verb+vm_region+ structs instead of just base address of
                        the allocation.
  \item \verb+dynmem+   - is a dynamic memory allocation system that allocates
                        \& frees contiguous blocks of physical memory.
  \item \verb+ptmapper+ - owns the statically created page tables (particularly
                        the master page table) and regions, and is also used to
                        allocate new page tables from the page table region.
  \item \verb+vm+       - vm runs various checks on virtual memory access,
                        copies data between user land and kernel space and
                        allocates memory for processes.
  \item mmu HAL -       is the abract MMU interface provided by \verb+mmu.h+
                        and \verb+mmu.c+.
  \item CPU specific MMU code is the module responsible of configuring the
        physical MMU layer and implementing the interface provided by
        \verb+mmu.c+
\end{itemize}


\section{Page Fault handling and VM Region virtualization}

\begin{enumerate}
\item DAB exception transfers execution to \verb+interrupt_dabt+ in \verb+XXX_int_handlers.S+
\item \verb+mmu_data_abort_handler()+ (\verb+XXX_mmu.c+) gets called
\item to be completed...
\end{enumerate}
